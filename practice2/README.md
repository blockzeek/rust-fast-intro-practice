# 所有权
- 所有权是Rust的出发点
- 每一个 值/资源 都有一个所有者。
- 任何一个时刻，一个资源只有一个所有者。
- 当所有者所在作用域结束的时候，资源会被释放掉。
    - 例如
    - ```
        fn main() {
            let a = 10u32;
            let b = a;
            println!("{a}");
            println!("{b}");
        }
        ```
    - 当执行 `let b = a`，值被复制，`b`具有对这个新的值的所有权。当 `main` 函数结束的时候，`a`和`b`两个变量就离开了作用域，其对应的两个值，就都被回收了。

## 移动 vs 复制
- 移动 by default
  - scalar types(?) (类似primitives?)
    - integers, floating-point numbers, Booleans, and characters
  - typles from scalar types
- 复制 by default
  - 以上`移动 by default`以外其他类型
- vs Java (and maybe other oop languages)
  - 对于 primitive types: 在赋值给另一个变量的时候，会直接复制它的值。
  - 对于 Object: 默认只会复制这个 Object 的引用给另一个变量（也就是所谓的浅拷贝）。
    - 浅拷贝也可以看成值复制，只不过复制的不是对象的实际内容，而是对那个实际内容的一个引用，而这个引用的地址值，就存在栈上的局部变量里面。
  - ```
      // rust
      fn main() {
          let s1 = String::from("I am a superman.");
          let s2 = s1;
          println!("{s1}"); //error
          println!("{s2}");
      }

      // java
      public class Main {
          public static void main(String[] args) {
              String s1 = "I am a superman.";
              String s2 = s1;
              System.out.println(s1);
              System.out.println(s2);
          }
      }
      ```
  - ^
    - Java默认做了引用的拷贝，并且新旧两个变量同时指向那个对象。
    - 而Rust没有这么做，Rust虽然也是把字符串的引用由 s1 拷贝到了 s2，但是只保留了最新的 s2 到字符串的指向，同时却把 s1 到字符串的指向给 “抹去”了。这就是 Rust编译器做的那个 “更多”的部分。

## 基于所有权规则，函数的写法会有所变化((?)复杂/不雅)。
- 例如，当函数需要使用某个值时，该值的所有权会被移动（move）到函数中，函数结束时所有权被释放。
- 但是，如果要在调用完函数后，继续用这个变量，我们采取的办法就是把那个值返回回来
  - ——把所有权转移回来。
- 所以(?)需要`引用`

# 引用
- 借用 vs 引用
  - 借用: 站在资源拥有者角度来说的; 借出使用
  - 引用: 站在想借这个资源的变量角度来说的; 引来使用
- 作用域
    - 引用（不可变引用和可变引用都是）变量的作用域不会长于所有权变量的作用域。
        - 不然就会出现悬锤引用了，这是典型的内存安全问题。
    - 一个资源的可变引用与不可变引用的作用域不能交叠（overlap），也可以说不能同时存在。
- Rust中的引用必定是有效的。

## 不可变引用
- `&x` 对变量 `x` 的不可变引用。
- 不可变引用可以被复制。
- 一个资源的不可变引用，可以同时存在多个。

## 可变引用
- `&mut x` 对变量 `x` 的可变引用。
- 可变引用不能被复制，只能被 move。
- 某个时刻对某个资源只能存在一个可变引用，不能有超过一个可变引用同时存在。
- 可变引用的存在是因为，如果要对一个变量绑定的值进行修改，我们只有拥有那个值的所有权才行。而很多时候，我们没法拥有那个值的所有权。因此需要一种方法，又是一种引用，又能够修改指向的那个值。这样就引入了可变引用。